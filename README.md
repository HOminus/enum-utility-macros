Matrix of possible enum helpers and for which enums they can be generated.

```text
------------------------|------|---------|---------|---------|
                        | Enum | TagEnum | RefEnum | MutEnum |
------------------------|------|---------|---------|---------|
Can be generated        |      |    X    |    X    |    X    |
########################|######|#########|#########|#########|
Is Function             |   X  |    X    |    X    |    X    |
------------------------|------|---------|---------|---------|
Unwrap Function         |   X  |         |    X    |    X    |
------------------------|------|---------|---------|---------|
UnwrapRef Function      |   X  |         |         |         |
------------------------|------|---------|---------|---------|
UnwrapMut Function      |   X  |         |         |         |
------------------------|------|---------|---------|---------|
ToTag Function          |   X  |         |    X    |    X    |
------------------------|------|---------|---------|---------|
AsRef Function          |   X  |         |         |         |
------------------------|------|---------|---------|---------|
AsMut Function          |   X  |         |         |         |
------------------------|------|---------|---------|---------|
Get                     |   X  |         |    X    |    X    |
------------------------|------|---------|---------|---------|
GetRef                  |   X  |         |         |         |
------------------------|------|---------|---------|---------|
GetMut                  |   X  |         |         |         |
------------------------|------|---------|---------|---------|
```
TagEnum, RefEnum and MutEnums are enums itself which can be generated.
The other items are functions which are implemented for the crossed enums.
For example:
```rust,ignore
#[generate_enum_helper(TagEnum, RefEnum, MutEnum, is, unwrap, unwrap_mut, to_tag, as_mut, get)]
enum MyEnum { Variant1(Type) }
```
generates code which looks like:
```rust,ignore
enum MyEnum { Varaint1(Type), ... }
enum MyEnumTag { Variant1, ... }
enum MyEnumRef<'a> { Variant1(&'a Type), ... }
enum MyEnumMut<'a> { Varaint1(&'a mut Type), ... }

impl MyEnum {
fn is_variant1(&self) -> bool {...} // And other is_... functions
fn unwrap_variant1(self) -> Type {...} // And other unwrap_ functions
fn unwrap_mut_variant1(&mut self) -> &mut Type { ... } // And other unwrap_mut functions
fn to_tag(&self) -> MyEnumTag {...}
fn as_mut(&self) -> MyEnumMut<'_> {...}
fn get_variant1(self) -> Option<Type> { ...} // And other variant functions
}

impl MyEnumTag {
fn is_variant1(self) -> bool {...} // And other is_... functions
}

impl<'a> MyEnumRef<'a> {
fn to_tag(&self) -> MyEnumTag { ... }
fn unwrap_variant1(&self) -> &'a mut Type { ... } // And other unwrap_ functions
}

```
generate_enum_helpers works with named and unnnamed variant fields. Also it works with variants having no, a single or multiple fields. In case of multiple fields, the unwrap functions return tuples. Further derive and attribute macros are applied to all generated enums except the TagEnum. Please report any issue on GitHub.
To see what code is generated by this proc macro you could use a command like `cargo expand`. Fo instance use `cargo expand --test named_multifield` to run `cargo expand` on a single integration test.